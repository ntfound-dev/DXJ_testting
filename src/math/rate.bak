//! Math for preserving precision of ratios and percentages (Odra-migration).
//!
//! Rates are internally scaled by a WAD (10^18) to preserve precision up to 18
//! decimal places. Underlying representation uses Odra's U256 type.

#![allow(clippy::assign_op_pattern)]
#![allow(clippy::ptr_offset_with_cast)]
#![allow(clippy::reversed_empty_ranges)]
#![allow(clippy::manual_range_contains)]
#![allow(missing_docs)]

use {
    crate::{error::LendingError, math::{common::*, decimal::Decimal}},
    odra::casper_types::U256,
    std::fmt,
};

/// Small decimal values, precise to 18 digits
#[derive(Clone, Copy, Debug, Default, PartialEq, PartialOrd, Eq, Ord)]
pub struct Rate(pub U256);

impl Rate {
    /// One
    pub fn one() -> Self { Self(Self::wad()) }

    /// Zero
    pub fn zero() -> Self { Self(U256::from(0)) }

    // OPTIMIZE: use const slice when fixed in BPF toolchain
    fn wad() -> U256 { U256::from(WAD) }

    /// Create scaled decimal from percent value
    pub fn from_percent(percent: u8) -> Self { Self(U256::from(percent as u64 * PERCENT_SCALER)) }

    /// Return raw scaled value
    #[allow(clippy::wrong_self_convention)]
    pub fn to_scaled_val(&self) -> u128 { 
        self.0.as_u128()
    }

    /// Create decimal from scaled value
    pub fn from_scaled_val(scaled_val: u128) -> Self { Self(U256::from(scaled_val)) }

    /// Calculates base^exp using exponentiation by squaring
    pub fn try_pow(&self, mut exp: u64) -> Result<Rate, LendingError> {
        let mut base = *self;
        let mut ret = if exp % 2 != 0 { base } else { Rate(Self::wad()) };

        while exp > 0 {
            exp /= 2;
            base = base.try_mul(base)?;

            if exp % 2 != 0 {
                ret = ret.try_mul(base)?;
            }
        }

        Ok(ret)
    }
}

impl fmt::Display for Rate {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut scaled_val = self.0.to_string();
        if scaled_val.len() <= SCALE {
            scaled_val.insert_str(0, &vec!["0"; SCALE - scaled_val.len()].join(""));
            scaled_val.insert_str(0, "0.");
        } else {
            scaled_val.insert(scaled_val.len() - SCALE, '.');
        }
        f.write_str(&scaled_val)
    }
}

impl TryFrom<Decimal> for Rate {
    type Error = LendingError;
    fn try_from(decimal: Decimal) -> Result<Self, Self::Error> {
        // Convert Decimal to Rate - this assumes Decimal's scaled value fits in u128
        Ok(Self(U256::from(decimal.to_scaled_val())))
    }
}

// Arithmetic traits adapted to return LendingError
impl crate::math::TryAdd for Rate {
    fn try_add(self, rhs: Self) -> Result<Self, LendingError> {
        Ok(Self(self.0.checked_add(rhs.0).ok_or(LendingError::MathOverflow)?))
    }
}

impl crate::math::TrySub for Rate {
    fn try_sub(self, rhs: Self) -> Result<Self, LendingError> {
        Ok(Self(self.0.checked_sub(rhs.0).ok_or(LendingError::MathOverflow)?))
    }
}

impl crate::math::TryDiv<u64> for Rate {
    fn try_div(self, rhs: u64) -> Result<Self, LendingError> {
        Ok(Self(self.0.checked_div(U256::from(rhs)).ok_or(LendingError::MathOverflow)?))
    }
}

impl crate::math::TryDiv<Rate> for Rate {
    fn try_div(self, rhs: Self) -> Result<Self, LendingError> {
        Ok(Self(
            self.0
                .checked_mul(Self::wad())
                .ok_or(LendingError::MathOverflow)?
                .checked_div(rhs.0)
                .ok_or(LendingError::MathOverflow)?
        ))
    }
}

impl crate::math::TryMul<u64> for Rate {
    fn try_mul(self, rhs: u64) -> Result<Self, LendingError> {
        Ok(Self(self.0.checked_mul(U256::from(rhs)).ok_or(LendingError::MathOverflow)?))
    }
}

impl crate::math::TryMul<Rate> for Rate {
    fn try_mul(self, rhs: Self) -> Result<Self, LendingError> {
        Ok(Self(
            self.0
                .checked_mul(rhs.0)
                .ok_or(LendingError::MathOverflow)?
                .checked_div(Self::wad())
                .ok_or(LendingError::MathOverflow)?
        ))
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn checked_pow() {
        assert_eq!(Rate::one(), Rate::one().try_pow(u64::MAX).unwrap());
    }
}